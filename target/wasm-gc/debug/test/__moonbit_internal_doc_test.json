{
  "drops": [],
  "patches": [
    {
      "name": "reactive__moonbit_internal_doc_test.mbt",
      "content": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntest \"signal_id\" {\n      let s = new(0)\n      assert_eq!(s.id(), \"signal#0\")  \n      let s2 = new(1, label=\"my_signal\")\n      assert_eq!(s2.id(), \"my_signal#1\")\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntest \"signal_val\" {\n      let s = new(0)\n      assert_eq!(s.val(), 0)\n      s.update(5)\n      assert_eq!(s.val(), 5)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntest \"signal_set\" {\n      let values = []\n      let s = new(0)\n      s.subscribe_permanent(fn(v) { values.push(v) })\n      assert_eq!(s.val(), 0)\n      s.set(5) // This will set the signal to 5 without notifying subscribers.\n      assert_eq!(s.val(), 5)\n      s.update(10) // This will notify subscribers with the new value.\n      assert_eq!(s.val(), 10)\n      assert_eq!(values, [0, 10])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntest \"signal_update\" {\n      let values = []\n      let s = new(0)\n      s.subscribe_permanent(fn(v) { values.push(v) })\n      assert_eq!(s.val(), 0)\n      s.update(5) // This will notify subscribers with the new value.\n      assert_eq!(s.val(), 5)\n      assert_eq!(values, [0, 5])\n      s.update(10) // This will notify subscribers with the new value.\n      assert_eq!(s.val(), 10)\n      assert_eq!(values, [0, 5, 10])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntest \"signal_unsubscribe\" {\n      let values = []\n      let s = new(0)\n      let sub = s.subscribe(fn(v) { values.push(v) })\n      assert_eq!(s.val(), 0)\n      s.update(5) // This will notify subscribers with the new value.\n      assert_eq!(s.val(), 5)\n      assert_eq!(values, [0, 5])\n      s.unsubscribe(sub) // This will unsubscribe the subscriber.\n      assert_eq!(s.val(), 5)\n      s.update(10) // This will not notify the unsubscribed subscriber.\n      assert_eq!(s.val(), 10)\n      assert_eq!(values, [0, 5])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntest \"signal_map\" {\n      let values = []\n      let s = new(0)\n      let s2 = s.map(fn(v) { v + 1 })\n      s2.subscribe_permanent(fn(v) { values.push(v) })\n      s.update(5) // This will trigger the subscriber with value 6.\n      s.update(10) // This will trigger the subscriber with value 11.\n      s.update(20) // This will trigger the subscriber with value 21.\n      inspect!(values, content=\"[1, 6, 11, 21]\")\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntest \"signal_map2\" {\n      let values = []\n      let s1 = new(1)\n      let s2 = new(2)\n      let s3 = @reactive.map2(s1, s2, fn(a, b) { a + b })\n      s3.subscribe_permanent(fn(v) { values.push(v) })\n      s1.update(3) // This will trigger the subscriber with value 5.\n      s2.update(4) // This will trigger the subscriber with value 7.\n      s1.update(5) // This will trigger the subscriber with value 9.\n      inspect!(values, content=\"[3, 5, 7, 9]\")\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntest \"signal_filter\" {\n      let filtered_values = []\n      let s = new(1)\n      let s2 = s.filter(fn(v) { v > 5 }, 0)\n      s2.subscribe_permanent_only(fn(v) { filtered_values.push(v) })\n      s.update(10) // This will trigger the subscriber with value 10.\n      s.update(7) // This will trigger the subscriber with value 7.\n      s.update(3) // This will not trigger the subscriber.\n      inspect!(filtered_values, content=\"[10, 7]\")\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntest \"signal_filter_map\" {\n      let mapped_values = []\n      let s = new(1)\n      let s2 = s.filter_map(fn(v) { if v > 5 { Some(v+2) } else { None } }, 0)\n      s2.subscribe_permanent_only(fn(v) { mapped_values.push(v) })\n      s.update(10) // This will trigger the subscriber with value 12.\n      s.update(7) // This will trigger the subscriber with value 9.\n      s.update(3) // This will not trigger the subscriber.\n      inspect!(mapped_values, content=\"[12, 9]\")\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntest \"select_one\" {\n      let values = []\n      let s1 = new(1)\n      let s2 = new(2)\n      let s3 = new(3)\n      let combined_signal = @reactive.select_one([s1, s2, s3])\n      combined_signal.subscribe_permanent_only(fn(v) { values.push(v) })\n      s1.update(4) // This will trigger the subscriber with value 4.\n      s2.update(5) // This will trigger the subscriber with value 5.\n      s3.update(6) // This will trigger the subscriber with value 6.\n      inspect!(values, content=\"[4, 5, 6]\")\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntest \"combine_pair\" {\n      let values = []\n      let s1 = new(1)\n      let s2 = new(2)\n      let s3 = @reactive.combine_pair(s1, s2)\n      s3.subscribe_permanent(fn(v) { values.push(v) })\n      s1.update(3) // This will trigger the subscriber with value (3, 2).\n      s2.update(4) // This will trigger the subscriber with value (3, 4).\n      s1.update(5) // This will trigger the subscriber with value (5, 4).\n      inspect!(values, content=\"[(1, 2), (3, 2), (3, 4), (5, 4)]\")\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntest \"combine_triple\" {\n      let values = []\n      let s1 = new(1)\n      let s2 = new(2)\n      let s3 = new(3)\n      let s4 = @reactive.combine_triple(s1, s2, s3)\n      s4.subscribe_permanent(fn(v) { values.push(v) })\n      s1.update(4) // This will trigger the subscriber with value (4, 2, 3).\n      s2.update(5) // This will trigger the subscriber with value (4, 5, 3).\n      s3.update(6) // This will trigger the subscriber with value (4, 5, 6).\n      s1.update(7) // This will trigger the subscriber with value (7, 5, 6).\n      inspect!(values, content=\"[(1, 2, 3), (4, 2, 3), (4, 5, 3), (4, 5, 6), (7, 5, 6)]\")\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntest \"combine_all\" {\n      let values = []\n      let s1 = new(1)\n      let s2 = new(2)\n      let s3 = new(3)\n      let s4 = new(4)\n      let combined_signal = @reactive.combine_all([s1, s2, s3, s4])\n      combined_signal.subscribe_permanent(fn(v) { values.push(v) })\n      s1.update(5) // This will trigger the subscriber with value [5, 2, 3, 4].\n      s2.update(6) // This will trigger the subscriber with value [5, 6, 3, 4].\n      s3.update(7) // This will trigger the subscriber with value [5, 6, 7, 4].\n      s4.update(8) // This will trigger the subscriber with value [5, 6, 7, 8].\n      inspect!(values, content=\"[[1, 2, 3, 4], [5, 2, 3, 4], [5, 6, 3, 4], [5, 6, 7, 4], [5, 6, 7, 8]]\")\n}\n"
    }
  ]
}